---
title: "censusprofiler"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{censusprofiler}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
address <- "60 W Walton St, Chicago, IL 60610"
```

Welcome to `censusprofiler`, a package designed to simplify regionalized census data capture. While `censusprofiler` can perform several functions, at its core, it takes a geographic point, draws a radius, and makes calls to the census api for geographical units around within that radius, and provides output that is more suited for presentation.

All census calls are made via the US Census API. In order to use the Census API (and `censusprofiler`), you will need an API key, which you can obtain here (https://api.census.gov/data/key_signup.html), To save the API key as an environmental variable, run `set_api_key()`.

This package was designed with the American Community Survey in mind. However, it is possible to obtain data from the Decennial census as well. Implementation of these additional data sources remains a TODO for the package.

# Workflows

This vingette provides a basic introduction to two kinds of workflows used with censusprofiler: single, and batch profile creation. The basic logic of `censusprofiler` is as follows: *Initial Setup* Data Setup Variable Profile Setup

*Profile Creation* Profile Call (single/batch) -\> Geo Processing -\> Census API call -\> Data Processing -\> Data Return

## Data Setup

For `censusprofiler` to work, several datasets must be loaded into the global environment. These include:

-   `ACS.GROUPS` and `ACS.VARS`: Dataframes containing all variables in the ACS 5-Year data.
-   `profileList`: Vector containing all `varBase` (concepts) the user desires to query from ACS. Future implementations may include interactive selection methods, but for now, the user is responsible to create a vector of applicable `varBase` (concepts) from `ACS.GROUPS.`
-   `profileVars`: Vector containing all `variables` the user desires to query. This is the true workhorse of the profile builder. The ACS API takes individual variables, not `varBase` (concepts) entries, so a master list of all individual variables must be created. To assist in this, use `profile_helper()`, an interactive variable builder that takes `profileList` and walks the user through selecting individual variables for the final profile call.

The preceeding objects are all required for `censusprofiler` to function, as you will be required to pass `profileList` and `profileVars` objects to many of the functions. `ACS.GROUPS/VARS` is implicitly required in most functions.

In addition to the required data, several datasets are available to make `censusprofiler` run more efficiently.

-   `geos`: A nested list containing sf tables of all state, county, tract, and block groups (as selected by the user). If not present in the global environment, or passed through functions, `geos` objects will be generated via download. This affects performance time significantly.
-   `stateCompare`: A profile object using supplied `profileVars` to create summary table of all variables in the user's profile, at the state level for comparison use in `displayTable()`.
-   `usCompare`: A profile object using supplied `profileVars` to create summary table of all variables in the user's profile, at the national level for comparison use in `displayTable()`.
-   `profile_stats`: A dataframe generated by querying every census_tract in the nation using the supplied `profileVars` list to calculate z-scores, medians, etc. for variables. This is primarily useful in conjunction with `displayTable()` and in rmarkdown reports. NB: The statistics table is generated off a master list created by making an ACS call across every US census tract. The resultant table is very large: [Number of Tracts x Number of Variables]. This typically results in a dataframe with millions of rows. As a result, the call itself takes time. However, the data is deleted and only the summary table is returned (unless otherwise desired by the user).

With the exception of the ACS variables, everything can be loaded via the `load_data()` function.

## Single Profile Creation

A profile is a geographically-bounded data call on provided variables. The resultant object is a complex list, including many different types of data. First, the function syntax though.

Once required data is loaded and available, run `create_profile()`. A simple call might look like this:

```         
profile <- create_profile(profileList=profileList,
               profileVars=profileVars,
               year=2021,
               Church.Name="Trinity Church",
               filterAddress="206 Clarendon St, Boston, MA 02116",
               filterRadius=1,
               geography="tract")
```

This returns a list object:

```{r}
names(profile)
```

The first list item is a dataframe containing geographic details about the entity around which the profile is built.

```{r}
names(profile$churchInfo)

profile$churchInfo
```

The second list item is a nested list of dataframes containing three types of data.

```{r}
names(profile$data[[1]])
```

Table `df` is a straight dump of all returns of each geographical area, ungrouped. Note that data processing has taken place. For a pure return from the census API, use `tidycensus::get_acs()` or `censusprofiler::get_census_data(...,saveToVariable=TRUE)`.

```{r}
head(profile$data[[1]]$df)
```

Tables `dfCount` and `dfNoSummary` are structured differently in that they provide summary counts for the entire radius. That is, they combine counts for whatever geographic areas are specified and provide summary output.

```{r}

head(profile$data[[1]]$dfCount)
```

The only difference between `dfCount` and `dfNoSummary` is that the latter excludes summary variables to provide cleaner output of individual subvariable breakdowns for tables. You don't always want summary stats to show up when displaying the how subvariables compare to one another.

```{r}
head(profile$data[[1]]$dfNoSummary)
```

While the list format can be a little unwieldy, we have packaged it in this way for user-end flexibility. That is, so the user can make a single profile call, and have access to various data formats at hand.

## Batch Profile Creation

In addition to creating a single profile, `censusprofiler` can also run a batch from a list of geocoded addresses, using `create_profile_batch()`.

Before running the batch, however, make sure you have a data object with addresses and coordinates. To simplify this, `censusprofiler` has a helper function, `geocoder_batch()`. This function takes the addresses provided, then tries the census-supplied geocoder. If this fails, it defaults to Open Street Map (using `tmaptools::geocode_OSM`).Please abide by any usage restrictions (see <https://operations.osmfoundation.org/policies/nominatim/>).

```{r}
head(churches)
```

```{r}
addresses <- geocoder_batch(churches)
head(addresses)
```

Once you have an address list, run the batch function.

```         
create_profile_batch(addressList = addresses,
                     year = 2021,
                     profileVars=profileVars,
                     profileList=profileList,
                     filterRadius=1)
```

This creates a list similar to that created by `create_profile()`, except with multiple rows.

```{r}
names(profile_batch)
```

```{r}
head(profile_batch$churchInfo)
```

The three available datasets can be accessed via `yourprofilevar$data[[n]]`.

```{r}
# Get census data for radius around Old West Church
head(profile_batch$data[[2]]$dfCount)
```

# Standalone Functions

`censusprofiler` provides two additional functions which can be implemented as standalone utilities, or in a rmarkdown report.

## displayTable()

To display data in an elegant table, call `displayTable()`. We rely on the `flextable` package for output. You will likely benefit more from creating your own table output. However, `displayTable()` is a standalone function, meaning that you can pass variables, an address, and radius to it, and generate a quick table on the requested information, without first generating a profile object. In short, it is a convenience function.

## map_census_data()

Additionally, we have employed the `tmap` package to provide mapping capacities to the data collected. `map_census_data()` is a standalone function, meaning you can pass a variable and address to it, and it will generate the map for that area, without first creating a profile object.
